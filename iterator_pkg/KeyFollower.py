import numpy as npimport h5pyimport osimport timefrom multiprocessing import Process    class SwmrProcess(Process):    passclass Follower():    def __init__(self,                 hdf5_file,                 key_datasets,                 timeout = 10,                 termination_conditions = ["timeout"]):                     self.hdf5_file = hdf5_file                     self.current_key = -1                     self.current_max = -1                     self.timeout = timeout                     self.key_datasets = key_datasets                     self.termination_conditions = termination_conditions                                                      def __iter__(self):        return(self)        def __next__(self):        if not self.is_finished():                        while not self._is_next():                time.sleep(1)                if self.is_finished():                    raise StopIteration                        if self._is_next():                self.current_key += 1                x = self.current_key                self._timer_reset()                return x                else:            raise StopIteration                    def reset(self):        self.current_key = -1        self.current_max = -1            def _timer_reset(self):        self.start_time = time.time()                                      #Returns the maximum readable key                def get_current_max(self):        current_max = []        for key_path in self.key_datasets:            dataset = self.hdf5_file[key_path]            print("Refreshing")            dataset.refresh()            current_max.append(np.nonzero(dataset[...].flatten())[0].max())        return np.asarray(current_max).min()                    def _is_next(self):                #assign current max to a variable and only call the function current_max when needed                if self.current_key == self.current_max:            print("self.current_key: {}, self.current_max: {}".format(self.current_key, self.current_max))            self.current_max = self.get_current_max()            print("self.current_max: {}".format(self.current_max))                if self.current_key < self.current_max:            return True        else:            return False                    def _timeout(self):        if time.time() > self.start_time + self.timeout:            return True        else:            return False                    def _finish_condition(self):        conditions = {"timeout": self._timeout(), "always_true" : True}                #Set finish to true if any of the termination conditions are met        finish = False        for condition in self.termination_conditions:            finish = finish or conditions[condition]                        #return conditions[self.termination_conditions[0]]        return finish                    def is_finished(self):        if (not self._is_next()) and (self._finish_condition()):            return True                else:            return False                                                                                                                                                                        